<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25" zv="Cache for Windows (x86-64) 2014.1 (Build 536U)" ts="2014-02-22 17:45:42">
<Class name="sc.min">
<Description><![CDATA[
Installation <example>
d ##class(sc.min).workdir("c:\temp\")
d ##class(sc.min).ignore("%")
d ##class(sc.min).ignore("sc.")
</example>]]></Description>
<Super>%Studio.SourceControl.Base</Super>
<TimeChanged>63240,63917.345966</TimeChanged>
<TimeCreated>62767,49709.824104</TimeCreated>

<Parameter name="DOMAIN">
<Description>
Text domain</Description>
<Default>sc</Default>
</Parameter>

<Parameter name="STORAGE">
<Description>
storage for settins</Description>
<Default>^sc</Default>
</Parameter>

<Method name="workdir">
<Description>
[g]et [w]ork [d]irectory
if work directory unknown then
return current database directory</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>value:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
     s wds = ..#STORAGE, default = $zu(12,"")
     if $d(value){ //set mode
      s value=$g(value) s:value="" value=default
      s @wds=value Q value
     } else { //get mode
      s wd=$g( @wds ) Q:wd'="" wd Q default
     }
]]></Implementation>
</Method>

<Method name="igns">
<Description>
[ign]ore code names [s]ettings</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[..#STORAGE_"(""skip"")"
]]></Implementation>
</Method>

<Method name="ignore">
<Description><![CDATA[
ignore code module with name started with <var>mask</var>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[mask:%String,&arr:%String=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    s gln=..igns() if $d(mask) { //set mode
       s @gln@(mask)="" 
    } 
    m arr = @gln
    Q $$$OK
]]></Implementation>
</Method>

<Method name="ignored">
<Description>
is ignored?</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>code:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    s arr = ..ignore(,.arr), ignored=0
    s mask="" for { s mask=$o(arr(mask)) Q:mask=""
        s pos = $f(code, mask) if pos=0 continue
        s check = $l( mask ) + 1
        if pos = check  { ;starts with
             s ignored=1 Q  
        }
    }
    Q ignored
]]></Implementation>
</Method>

<Method name="code2file">
<Description>
module name convert to file name</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>code:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[##class(%File).NormalizeFilename(code_".xml",..workdir())
]]></Implementation>
</Method>

<Method name="code2filev0">
<Description>
code module name into file name 
compatible with previous version</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>code:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 #define parse(%code) s len=$l(%code,"."), name=$P(%code,".",1,len-1), ext=$P(%code,".",len)
 s len=0, (name,ext)=""
 $$$parse(code)
 s path = "_"_ext_"\"_$tr(name,".","\")_".xml"
 Q ..workdir()_path
]]></Implementation>
</Method>

<Method name="generated">
<Description>
Is generated?</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>code:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    s sequence=$lb("CSP","CLS","MAC","INT")
    
    s len=0,name="",ext=""
    #define parse(%code) s len=$l(%code,"."), name=$P(%code,".",1,len-1), ext=$P(%code,".",len)
        
    $$$parse(code) s codelvl=$LF(sequence,ext)
    
    s src=##class(%RoutineMgr).GetOther(name,ext,-1) QUIT:src="" 0 ;created by user
    
    #;now ext for src
    $$$parse(src) s srclvl=$LF(sequence,ext) 
    
    if srclvl<codelvl QUIT 1 ;generated
    
    Q 0 ;created by user
]]></Implementation>
</Method>

<Method name="handler">
<Description>
handler for studio events</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>code:%String,event:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   
    s skip=0, txt=""
    if ..ignored(code) {
        s txt=$$$Text("IGNORED ")_code, skip=1
    } elseif ##class(%RoutineMgr).IsCSPName(code){
        s txt=$$$Text("CSPNAME ")_code, skip=1
    } elseif ..generated(code) {
        s txt=$$$Text("GENERATED ")_code, skip=1
    } 
    
    #define msg(%txt) s io=$io u 0 w !,%txt u io
    
    if skip {
      $$$msg(txt) Q $$$OK      
    }
    
    #; compatible with previous version        
    s file=..code2filev0(code) ;..code2file(code)
    
    s exist=##class(%File).Exists(file), filets=""
    if exist {
        s filetsh=##class(%Library.File).GetFileDateModified(file) ;horolog
        s filets=$zdt(filetsh,3)
    } 
    s codets=##class(%RoutineMgr).TS(code)
    
    Q:codets=filets $$$OK ;timestamps equal
    
    s txt="", sc=1
    if codets]filets { ;export from database
        
        s dir = ##class(%File).GetDirectory(file)
        s sc= ##class(%File).CreateDirectoryChain(dir) ;check
        s sc=$system.OBJ.Export(code,file,"-d /diffexport") 
        s txt=code_$$$Text(" -> ")_file
       
    } elseif filets]codets { ;import from file
        
        #; Flags: -d - not display, -l - no lock
        #;s sc=$$Import^%occSAX(filename,"fv-d-l")
        #;s sc=$$Import^%apiRTN(filename,"all,replace,nocompile,lock=0",,,,"-d")
        
        try { 
        
        /*
        * Именно этот фрагмент кода падает с ошибкой 
        * при РУЧНОМ импорте проекта через Studio
        * ОШИБКА #6301: Ошибка анализатора SAX XML: <NULL VALUE>ParseFileBoot+25^%occSAX
        * Студия ставит блокировку на выбранные классы классы, запускает импорт
        * и генерирует события, вызывающие импорт
        */
        #; Flags: -d - not display, -l - no lock
        s sc=$system.OBJ.Load(file,"-d-l")  
       
        } catch e {
          s txt = $$$Text("Load project from terminal: ")_code  
          $$$msg(txt)  
        }
        
        s txt=file_$$$Text(" -> ")_code
    
    }
    
    s io=$io u 0 w !,txt     
    d:$$$ISERR(sc) $system.OBJ.DisplayError(sc)
    u io  
    Q sc
]]></Implementation>
</Method>

<Method name="export1">
<Description>
first export </Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    s sql="Select ID From %Dictionary.ClassDefinition"
    s rs=##class(%SQL.Statement).%ExecDirect(.stm,sql)
    for { s sc=rs.%Next() Q:'sc
      
      #;проверка на пропускаемые и генерируемые
      s cls=rs.ID, code=cls_".CLS"
      if ..ignored(cls) continue  
      if ..generated(code) continue
      s file=..code2file(code)
      s sc=$system.OBJ.Export(code,file,"-d /diffexport") 
      w:+sc !,code," -> ", file
      
    }
    k rs,stm
    QUIT 1
    
    #; low level export without encoding
    #;s sc=$$Export^%apiRTN("filename","c:\temp\DFPRK.INT","","WNSK\RAW\","-d /diffexport",.err)
]]></Implementation>
</Method>

<Method name="OnBeforeLoad">
<Description>
Import the file from the external format into Cache.
This is called before the actual load of data to give the chance
to load the item from an external format.</Description>
<FormalSpec>InternalName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[    Quit ..handler(InternalName)
]]></Implementation>
</Method>

<Method name="OnAfterSave">
<Description>
This is called after the item has been saved to the database.
It may be passed a reference to the object representing the item just saved</Description>
<FormalSpec>InternalName:%String,Object:%RegisteredObject=$$$NULLOREF</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[    Quit ..handler(InternalName)
]]></Implementation>
</Method>

<Method name="OnAfterCompile">
<Description>
Called after the compile of the item is done.
Есть вероятность, что после компиляции исходник поменяется, например хранение
или студия может добавить форматирование (перевод строки перед фигурными скобками)</Description>
<FormalSpec>InternalName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[    Quit ..handler(InternalName)
]]></Implementation>
</Method>

<Method name="OnAfterDelete">
<Description>
care
Called after an item is deleted.</Description>
<FormalSpec>InternalName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    s file=..code2file(InternalName), sc=$$$OK
    s:##class(%File).Exists(file) sc=##class(%File).Delete(file)
    s txt=$$$Text(" DELETED ")_file
    s io=$io u 0 w:$$$ISOK(sc) !,txt 
        if $$$ISERR(sc) {
             w !,txt
             d $system.OBJ.DisplayError(sc)
        }
    u io
    Q sc
]]></Implementation>
</Method>

<Parameter name="Flags">
<Description><![CDATA[
Used to control which dialogs appear in Studio, if the position is '1'
then this dialog will appears and if it is '0' the <method>UserAction</method>
will be called to determine what to do. This is included for backward compatibilty.
The dialog are:<ul>
<li>1 : Present dialog on check in</li>
<li>2 : Present dialog on check out</li>
<li>3 : Ask to add new item to source control</li>
<li>4 : Ask to remove deleted item from source control</li></ul>Parameter Flags]]></Description>
<Type>STRING</Type>
<Default>0000</Default>
</Parameter>
</Class>
</Export>
